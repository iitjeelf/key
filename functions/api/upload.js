// ===========================================
// CLOUDFLARE WORKER - /functions/api/upload.js
// ===========================================
// With Google Drive PDF Backup
// ===========================================

export async function onRequestPost(context) {
  try {
    const GITHUB_TOKEN = context.env.GITHUB_TOKEN;
    const GITHUB_USER = context.env.GITHUB_USER || "iitjeelf";
    const GOOGLE_APPS_SCRIPT_URL = context.env.GOOGLE_APPS_SCRIPT_URL;
    
    if (!GITHUB_TOKEN) {
      return errorResponse("No GitHub token");
    }
    
    const formData = await context.request.formData();
    const className = formData.get('class').toLowerCase();
    const filename = formData.get('filename');
    const content = formData.get('content');
    const type = formData.get('type') || 'question';
    
    console.log(`=== UPLOAD START ===`);
    console.log(`Class: ${className}, Type: ${type}`);
    
    // Ensure GitHub repo exists
    await ensureRepo(GITHUB_USER, className, GITHUB_TOKEN);
    
    let filePath;
    let message;
    
    if (type === 'answer') {
      // ANSWER: answer-key.txt in ROOT
      filePath = 'answer-key.txt';
      message = `Update answer key for ${className.toUpperCase()}`;
    } else {
      // QUESTION: in questions folder
      filePath = `questions/${filename}`;
      message = `Upload question: ${filename} to ${className.toUpperCase()}`;
    }
    
    // Upload to GitHub
    const result = await uploadFile(
      GITHUB_USER,
      className,
      filePath,
      content,
      GITHUB_TOKEN,
      message
    );
    
    console.log(`=== GITHUB UPLOAD SUCCESS ===`);
    
    // ===== GOOGLE DRIVE BACKUP (for answer keys only) =====
    if (type === 'answer' && GOOGLE_APPS_SCRIPT_URL) {
      // Don't await - run in background
      uploadToGoogleDrive(content, className, GOOGLE_APPS_SCRIPT_URL)
        .then(driveResult => {
          console.log('✓ Google Drive backup complete');
        })
        .catch(driveError => {
          console.error('✗ Google Drive backup failed:', driveError);
        });
    }
    // ====================================================
    
    return successResponse(`Uploaded to ${className.toUpperCase()}`, result.url);
    
  } catch (error) {
    console.error('=== UPLOAD ERROR ===');
    console.error(error);
    return errorResponse(error.message);
  }
}

// ===== GOOGLE DRIVE UPLOAD FUNCTION =====
async function uploadToGoogleDrive(content, className, appsScriptUrl) {
  try {
    console.log(`=== GOOGLE DRIVE BACKUP START ===`);
    
    // Format date: DD-MM-YYYY
    const today = new Date();
    const day = today.getDate().toString().padStart(2, '0');
    const month = (today.getMonth() + 1).toString().padStart(2, '0');
    const year = today.getFullYear();
    const dateStr = `${day}-${month}-${year}`;
    
    // Create filename: DD-MM-YYYY_Section_AnswerKey.pdf
    const filename = `${dateStr}_${className.toUpperCase()}_AnswerKey.pdf`;
    
    console.log(`Creating PDF: ${filename}`);
    
    // Create PDF from content
    const pdfBuffer = createSimplePDF(content, className, dateStr);
    
    // Encode PDF to base64
    const base64PDF = btoa(pdfBuffer);
    
    // Send to Google Apps Script
    const response = await fetch(appsScriptUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        filename: filename,
        content: base64PDF
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      console.log(`✓ Google Drive: ${result.url}`);
    } else {
      console.error(`✗ Google Drive error:`, result.error);
    }
    
    return result;
    
  } catch (error) {
    console.error(`✗ Google Drive exception:`, error);
    throw error;
  }
}

// ===== SIMPLE PDF CREATION =====
function createSimplePDF(content, className, dateStr) {
  // Decode base64 content from frontend
  const decodedContent = atob(content);
  
  // Simple PDF structure
  return `%PDF-1.4
1 0 obj
<</Type/Catalog/Pages 2 0 R>>
endobj
2 0 obj
<</Type/Pages/Kids[3 0 R]/Count 1>>
endobj
3 0 obj
<</Type/Page/Parent 2 0 R/Resources<</Font<</F1 4 0 R>>>> /MediaBox[0 0 612 792]/Contents 5 0 R>>
endobj
4 0 obj
<</Type/Font/Subtype/Type1/BaseFont/Helvetica>>
endobj
5 0 obj
<</Length 2000>>
stream
BT
/F1 16 Tf
50 750 Td
(LFJC ANSWER KEY - ${className.toUpperCase()}) Tj
/F1 12 Tf
0 -30 Td
(Date: ${dateStr}) Tj
0 -30 Td
(----------------------------------------) Tj
0 -20 Td
(${decodedContent.replace(/\n/g, ' ) Tj\n0 -20 Td (')}) Tj
0 -30 Td
(----------------------------------------) Tj
0 -20 Td
(Generated by LFJC Teacher Portal) Tj
ET
endstream
endobj
xref
0 6
0000000000 65535 f 
0000000010 00000 n 
0000000056 00000 n 
0000000111 00000 n 
0000000212 00000 n 
0000000274 00000 n 
trailer
<</Size 6/Root 1 0 R>>
startxref
450
%%EOF`;
}

// ===== GITHUB FUNCTIONS =====
function githubHeaders(token, includeContentType = false) {
  const headers = {
    'Authorization': `token ${token}`,
    'User-Agent': 'LFJC-Portal',
    'Accept': 'application/vnd.github.v3+json'
  };
  
  if (includeContentType) {
    headers['Content-Type'] = 'application/json';
  }
  
  return headers;
}

function successResponse(message, url = null) {
  const response = { success: true, message };
  if (url) response.url = url;
  
  return new Response(JSON.stringify(response), {
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*'
    }
  });
}

function errorResponse(message) {
  return new Response(JSON.stringify({
    success: false,
    message: message || 'Upload failed'
  }), {
    status: 500,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*'
    }
  });
}

async function ensureRepo(username, repoName, token) {
  const repoUrl = `https://api.github.com/repos/${username}/${repoName}`;
  
  try {
    const checkResponse = await fetch(repoUrl, {
      headers: githubHeaders(token)
    });
    
    if (checkResponse.ok) {
      console.log(`✓ Repo ${repoName} exists`);
      return true;
    }
  } catch (error) {}
  
  // Create repo
  console.log(`Creating repo: ${repoName}`);
  const createResponse = await fetch('https://api.github.com/user/repos', {
    method: 'POST',
    headers: githubHeaders(token, true),
    body: JSON.stringify({
      name: repoName,
      private: false,
      description: `LFJC Class ${repoName.toUpperCase()}`,
      auto_init: true
    })
  });
  
  if (!createResponse.ok) {
    const error = await createResponse.json();
    throw new Error(`Failed to create repo ${repoName}: ${error.message}`);
  }
  
  console.log(`✓ Repo ${repoName} created`);
  return true;
}

async function uploadFile(username, repoName, filePath, content, token, message) {
  const fileUrl = `https://api.github.com/repos/${username}/${repoName}/contents/${filePath}`;
  
  // Get SHA if file exists
  let sha = null;
  try {
    const checkResponse = await fetch(fileUrl, {
      headers: githubHeaders(token)
    });
    
    if (checkResponse.ok) {
      const fileData = await checkResponse.json();
      sha = fileData.sha;
      console.log(`✓ File exists, will update (SHA: ${sha?.substring(0, 8)}...)`);
    } else {
      console.log(`✗ File not found, will create new`);
    }
  } catch (error) {
    console.log(`✗ Error checking file: ${error.message}`);
  }
  
  // Prepare upload data
  const uploadData = {
    message: message,
    content: content,
    branch: 'main'
  };
  
  if (sha) {
    uploadData.sha = sha;
  }
  
  // Upload to GitHub
  const uploadResponse = await fetch(fileUrl, {
    method: 'PUT',
    headers: githubHeaders(token, true),
    body: JSON.stringify(uploadData)
  });
  
  if (!uploadResponse.ok) {
    const errorText = await uploadResponse.text();
    throw new Error(`GitHub API error: ${uploadResponse.status}`);
  }
  
  const result = await uploadResponse.json();
  
  return {
    url: result.content.html_url,
    sha: result.content.sha
  };
}
